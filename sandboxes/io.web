\def\title{SAFE IO LIBRARY (VERSION 2.0)}
\def\topofcontents{\null\vfill
  \centerline{\titlefont MAGS: Safe I/O Library}
  \vskip 15pt
  \centerline{(Version 2.0)}
  \vfill}
\def\botofcontents{\vfill
\noindent
Copyright $\copyright$ 2012
Joshua D. Cox
\smallskip\noindent
Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
\smallskip\noindent
THE SOFTWARE IS PROVIDED ``AS IS'' AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
}

@* Introduction.
This library contains procedures for constructing and 
manipulating a virtual file system for a sandbox environment.

@(io.sls@>=
(library (mags io)
   (export
    virtual-filesystem
    current-space-used
    file-exists?
    touch
    mkdir
    path-lookup
    open-input-file
    open-output-file
    call-with-input-file
    call-with-output-file
    with-input-from-file
    with-output-to-file
    close-port)
   (import
      (srfi :64)
      (mags sandbox)
      (except (chezscheme)
         delete-file
         file-exists?
         open-input-file
         open-output-file
         call-with-input-file
         call-with-output-file
         with-input-from-file
         with-output-to-file
	 close-port))
   (include "filesystemRecord.ss"))

@* Overview.
This library creates a sandbox virtual file system. The main purpose
of this sandbox is to enable the mags auto-grading system to grade
scheme code that can input/output to files. By creating a virtual
file system, space usage will be able to be controlled as well as
the ability to maintain the integrity of the top-level filesystem.

@* I/O Operations.
Listed below are the I/O operations that are going to be used when 
creating, managing, and manipulating the virtual filsystem that this
library outputs. As we are working with virtual filesystems, there
will be some procedures that will need to be rewritten to allow
for accessing ports on the virtual filesystem. However, there
are others that can remain as they are, as they only touch ports.


@ Procedures that require new definitions.


\medskip \noindent {\tt open-file-input-port}
\medskip \indent The above procedure takes a path, file-options, 
a buffer mode, and a transcoder and opens an input port at a 
specific location that you give for path. This procedure touches
a file

\medskip \noindent {\tt open-file-output-port}
\medskip \indent The above procedure takes a path, file-options, a 
buffer mode, and a transcoder and opens an output port at a specific 
location that you give for path. This procedure touches a file.

\medskip \noindent {\tt open-file-input/output-port}
\medskip \indent The above procedure takes a path, file-options, a 
buffer mode, and a transcoder and opens an input/output port for a 
file at a specific location that you give for path. This procedure 
touches a file.

\medskip \noindent {\tt open-input-file}
\medskip \indent This procedure opens a port to a specific path, as if
by using open-file-input-port with default options. This procedure 
touches a file.

\medskip \noindent {\tt open-output-file}
\medskip \indent open-output-file opens a port to a specific path, as if
by using open-file-output-port with default options. This procedure
touches a file.

\medskip \noindent {\tt call-with-input-file}
\medskip \indent This procedure takes a path and a procedure. It opens
an input port as if by using open-file-input-port and then passes
it to the subsequent procedure. This procedure touches a file.

\medskip \noindent {\tt call-with-output-file}
\medskip \indent This procedure takes a path and a procedure. It opens
and input port as if by using open-file-output-port and then passes it
to the subsequent procedure. This procedure touches a file.

\medskip \noindent {\tt with-input-from-file}
\medskip \indent This procedure takes a path and a thunk (a procedure
that takes zero arguments). It opens an input port temporarily, as if by 
using open-file-input-port while the thunk runs. If thunk returns, the 
port is closed and the current input port is restored to its previous 
value. This procedure touches a file.

\medskip \noindent {\tt with-output-to-file}
\medskip \indent This procedure takes a path and a thunk (a procedure
that takes zero arguments). It opens an output port temporarily, as if 
by using open-file-output-port while the thunk runs. If thunk returns,
the port is closed and the current output port is restored to its previous
value. This procedure touches a file. 

\medskip \noindent {\tt file-exists?}
\medskip \indent This predicate takes a path and returns true if the 
file exists, and false if it doesn't. This predicate touches a file.

\medskip \noindent {\tt delete-file}
\medskip \indent This procedure takes a path represented by a string
and removes the file if it exists and can be deleted. If otherwise, it
returns an error. This procedure touches a file.


@ Procedures that don't require redefinitions.


\medskip \noindent {\tt current-input-port}
\medskip \indent This procedure takes zero arguments and returns 
the input port that is open. This procedure touches a port.

\medskip \noindent {\tt current-output-port}
\medskip \indent This procedure takes zero arguments and returns 
the output port that is open. This procedure touches a port.

\medskip \noindent {\tt port?}
\medskip \indent This predicate takes one argument and returns 
whether it is a port or not. This predicate touches a port.

\medskip \noindent {\tt close-port}
\medskip \indent This procedure takes a port and closes it. This 
procedure touches a port.

\medskip \noindent {\tt read}
\medskip \indent This procedure takes a port and returns a Scheme datum
object or an eof object that is read from the file. Read is different
from get-datum in the fact that in the chance that an input port is not
specified, it defaults to the current input port. This procedure touches
a port.

\medskip \noindent {\tt read-char}
\medskip \indent This procedure takes a port and returns the next
character from the port. read-char is different from get-char in the 
fact that if an input port is not supplied, it defaults to the current
input port. This procedure touches a port.

\medskip \noindent {\tt peek-char}
\medskip \indent This procedure takes a port and returns the next
character form the port. peek-char is different from lookahead-char
in the fact that if an input port is not supplied, it default to the 
current input port. This procedure touches a port.

\medskip \noindent {\tt write}
\medskip \indent This procedure takes an object and an output port and
writes the object to the output port specified. write is different from
put-datum by the fact that if no output port is specified, it defaults
to the current output port. This procedure touches a port.

\medskip \noindent {\tt display}
\medskip \indent Similar to write, this procedure takes an object and
an output port and write to prementioned port. However, it differs from
write by printing strings and characters as if by using put-string
or put-char (it prints strings and chars without their special characters
syntax). This procedure touches a port.

\medskip \noindent {\tt write-char}his procedure takes zero arguments and returns 
the output port that is open. This procedure touches a port.

\medskip \noindent {\tt port?}
\medskip \indent This predicate takes one argument and returns 
whether it is a port or not. This predicate touches a port.

\medskip \noindent {\tt close-port}
\medskip \indent This procedure takes a port and closes it. This 
procedure touches a port.

\medskip \noindent {\tt read}
\medskip \indent This procedure takes a port andhis procedure takes zero arguments and returns 
the output port that is open. This procedure touches a port.

\medskip \noindent {\tt port?}
\medskip \indent This predicate takes one argument and returns 
whether it is a port or not. This predicate touches a port.

\medskip \noindent {\tt close-port}
\medskip \indent This procedure takes a port and closes it. This 
procedure touches a port.

\medskip \noindent {\tt read}
\medskip \indent This procedure takes a port and returns a Scheme datum
object or an eof object that is read from the file. Read is different
from get-datum in the fact that in the chance that an input port is not
specified, it defaults to the current input port. This procedure touches
a port.

\medskip \noindent {\tt read-char}
\medskip \indent This procedure takes a port and returns the next
character from the port. read-char is different from get-char in the 
fact that if an input port is not supplied, it defaults to the current
input port. This procedure touches a port.

\medskip \noindent {\tt peek-char}
\medskip \indent This procedure takes a port and returns the next
character form the port. peek-char is different from lookahead-char
in the fact that if an input port is not supplied, it default to the 
current input port. This procedure touches a port.

\medskip \noindent {\tt write}
\medskip \indent This procedure takes an object and an output port and
writes the object to the output port specified. write is different from
put-datum by the fact that if no output port is specified, it defaults
to the current output port. This procedure touches a port.

\medskip \noindent {\tt display}
\medskip \indent Similar to write, this procedure takes an object and
an output port and write to prementioned port. However, it differs from
write by printing strings and characters as if by using put-string
or put-char (it prints strings and chars without their special characters
syntax). This procedure touches a port.

\medskip \noindent {\tt write-char}
\medskip \noindent This procedure takes a char and an output port and
writes the char to the file in the open port. This procedure is similar
to put-char, differing in the fact that if no output port is specified,
it will default to the current output port. This procedure touches
a port. returns a Scheme datum
object or an eof object that is read from the file. Read is different
from get-datum in the fact that in the chance that an input port is not
specified, it defaults to the current input port. This procedure touches
a port.

\medskip \noindent {\tt read-char}
\medskip \indent This procedure takes a port and returns the next
character from the port. read-char is different from get-char in the 
fact that if an input port is not supplied, it defaults to the current
input port. This procedure touches a port.

\medskip \noindent {\tt peek-char}
\medskip \indent This procedure takes a port and returns the next
character form the port. peek-char is different from lookahead-char
in the fact that if an input port is not supplied, it default to the 
current input port. This procedure touches a port.

\medskip \noindent {\tt write}
\medskip \indent This procedure takes an object and an output port and
writes the object to the output port specified. write is different from
put-datum by the fact that if no output port is specified, it defaults
to the current output port. This procedure touches a port.

\medskip \noindent {\tt display}
\medskip \indent Similar to write, this procedure takes an object and
an output port and write to prementioned port. However, it differs from
write by printing strings and characters as if by using put-string
or put-char (it prints strings and chars without their special characters
syntax). This procedure touches a port.

\medskip \noindent {\tt write-char}
\medskip \noindent This procedure takes a char and an output port and
writes the char to the file in the open port. This procedure is similar
to put-char, differing in the fact that if no output port is specified,
it will default to the current output port. This procedure touches
a port.
\medskip \noindent This procedure takes a char and an output port and
writes the char to the file in the open port. This procedure is similar
to put-char, differing in the fact that if no output port is specified,
it will default to the current output port. This procedure touches
a port.

\medskip \noindent {\tt close-input-port}
\medskip \indent This procedure takes an input port and performs the
procedure of closing the port. This procedure is equivalent to the
close-port procedure. This procedure touches a port.

\medskip \noindent {\tt close-output-port}
\medskip \indent This procedure takes an output port and performs the
procedure of closing the port. This procedure is equivalent to the
close-port procedure. This procedure touches a port.


@* Current Virtual Filesystem.
The following creates a parameter that represents the current virtual
filesystem that is being used. This virtual filesystem is a unique
ADT created by using records. The filesystem record holds a list
of nodes held in the root level of the filesystem. These nodes can be 
either files or directories.


@p
(define-record-type filesystem
   (fields (mutable filelist fs-contents fs-contents!)
	   (mutable maxsize))
      (protocol
         (lambda (n)
            (lambda (filelist maxsize)
               (unless (list? filelist)
                  (error 'make-filesystem "filelist is not a list" filelist))
	       (unless (>= maxsize 0)
		  (error 'make-filesystem "size is not a valid integer" size))
               (n filelist maxsize)))))


(define virtual-filesystem
   (make-parameter
      (make-filesystem '() 500)))


@ Test cases for the Virtual Filesystem.

@(io-test.ss@>=
(test-begin "test-virtual-filesystem")
(virtual-filesystem)
(test-assert "filesystem1 == filesystem" (filesystem? filesystem1))
(test-end "test-virtual-filesystem")

@* Filesystem Space Constraints.
In order to make sure that everything in our virtual filesystem
is maintained and controlled by the operator of the system,
we can add some functionality that will bring into play Filesystem
Space Constraints. What this means is that when you initialize your
filesystem, you can specify the maximum amount of space that you 
want your filesystem to take up. 

@ |space-used-in-filesystem| is a procedure that takes a filelist
and returns the total amount of space taken up within that filelist.
It recursively travels down the filelist. If it encounters a file,
it adds the size onto the total. If it encounters a directory,
it will add up the sizes of all the files in the directory and then
back out and return to the main filelist.

@p
(define space-used-in-filesystem
  (lambda (ls)
    (cond
      [(null? ls) 0]
      [(file? (car ls)) (+ (node-size (car ls)) 
			(space-used-in-filesystem (cdr ls)))]
      [else
	(+ (space-used-in-filesystem (directory-nodes (car ls))) 
	   (space-used-in-filesystem (cdr ls)))])))

@ |current-space-used| holds a value that represents the current 
space taken up by files inside your |virtual-filesystem|.

@p
(define current-space-used
  (lambda ()
   (space-used-in-filesystem 
    (fs-contents (virtual-filesystem)))))

@ Space Usage Tests.

@(io-test.ss@>=
(test-begin "test-space-usage")
(virtual-filesystem)
(test-equal? "empty fs takes up zero space" 0 (current-space-used))

(fs-contents! (virtual-filesystem)
	      (cons (make-file "file1.txt" 4 "data")
		    (fs-contents (virtual-filesystem))))
(test-equal? "new fs takes up 4 space" 4 (current-space-used))

(fs-contents! (virtual-filesystem)
	      (cons (make-file "file2.txt" 5 "data1")
		    (fs-contents (virtual-filesystem))))
(test-equal? "new fs takes up 9 space" 9 (current-space-used))
(test-end "test-space-usage")


@* Files and Directories.
Files and Directories are subtypes of nodes. As nodes, they both have
names and size, but as separate subtypes they also have unique qualities 
by which we can identify them. Files, in addition to having names and 
sizes, have data and a field which denotes whether they are open or not.
Directories, in addition to having names and sizes, have children, which 
appear as others files and directories.

@p
(define-record-type node
   (fields (mutable name) (mutable size))
      (protocol
         (lambda (n)
            (lambda (name size)
               (unless (string? name)
                  (error 'make-node "name is not a string" name))
               (unless (>= size 0)
                  (error 'make-node "size is not a valid integer" size))
               (n name size)))))

@ |File| is a record-type that is used to create and manage a file-node.
It contains everything that a node contains (name and size) as well as
an extra field called data that contains the contents of the file in a
string. Additionally, it also has a field that contains a boolean (true
or false) that tells whether the file is open or not.

@p
(define-record-type file (parent node)
   (fields (mutable data) (mutable open))
      (protocol
         (lambda (p)
            (lambda (name size data)
               (unless (string? data)
                  (error 'make-file "data is not a string" data))
               ((p name size) data #f)))))

@ |Directory| is a type of node that contains a field "nodes" that 
contains a list of nodes.

@p
(define-record-type directory (parent node)
   (fields (mutable nodes))
      (protocol
         (lambda (p)
            (lambda (name nodes)
               (unless (list? nodes) 
                  (error 'make-directory "not a list" nodes))
               (unless (for-all node? nodes)
                  (error 'make-directory "directory can only contain nodes" nodes))
               ((p name 0) nodes)))))

@* Convenience Procedures.
Defined below are a series of procedures that will help in maintaining,
manipulating, and accessing your virtual filesystem.

@ |touch| is a procedure that will create a blank file.

@p
(define touch
  (lambda (string)
    (make-file string 0 "")))

@ |mkdir| is a procedure that will create an empty directory.

@p
(define mkdir
  (lambda (string)
    (make-directory string '())))

@ |close-port| is a procedure that takes a node and closes it's
port if it currently has one open. Below is a rewritten procedure
to take into account our record-datatype file. Because we replace 
the data of the file with a port, a slight change is necessary to
access the data position inside the file.

@p
(define close-port-new
  (lambda (node)
    (assert (file? node))
    (assert (file-open node))
    (close-port (file-data node))))

@ |search-filelist| is a simple list recursion procedure that will
find and return a node if one exists, and false if the node doesn't
exist.

@p
(define search-filelist
  (lambda (filelist node)
    (cond
      [(null? filelist) #f]
      [(equal? node (node-name (car filelist)))
       (car filelist)]
      [else
	(search-filelist (cdr filelist) node)])))

@ |path-lookup| takes a path and returns a node if it exists, and 
returns an error if it doesn't. The procedure runs through the 
let-loop. temp-path holds all the nodes that have not been searched
for. If temp-path is empty, we can deduce that we have reached the
end of our search for a file, and it will return either a node or \#f.

\medskip\noindent
However, if we have not reached the end of our path, we still have
the possibilities of searching for the next directory in our path,
or returning \#f. If the node searched for is returned as a node,
we also have to check if the node is a file. If it is a file, then
we cannot go further into the filesystem to complete the path. If it 
isn't a file, then it must be a directory and we can continue our 
search.

@p
(define path-lookup
   (lambda (path)
      (let loop ([temp-path (path-rest path)]
                 [filelist (fs-contents (virtual-filesystem))])
         (let ([first-node (path-first temp-path)])
            (let ([node (search-filelist filelist first-node)])
               (cond
                  [(equal? (path-first temp-path) "")
		    (search-filelist filelist temp-path)]
                  [else
                     (if (node? node)
                         (if (file? node)
                             #f
                             (loop (path-rest temp-path)
                                   (directory-nodes node)))
                          #f)]))))))
                                   
@ Test Cases for |path-lookup|.
(test-begin "path-lookup")
(fs-contents! (virtual-filesystem)
	      (cons (make-directory "dir" 
		      (cons (make-file "file1" 4 "data")
			    '()))
		    (fs-contents (virtual-filesystem))))

(test-equal? "can find a directory node" 
  (car (fs-contents (virtual-filesystem)))
  (path-lookup "/dir"))

(test-end "path-lookup")


@* Virtual Ports.
To access the files on our virtual filesystem for reading or writing,
we have to utilize ports. However, since we have defined our own type
of filesystem, we will also have to define our own port initialization.


@p
(define make-virtual-textual-input-port 
   (lambda (node)
      (assert (file? node))
      (let ([file node]
            [filename (node-name node)]
            [filecontents (file-data node)]
            [portpos 0])
         (when (file-open file)
            (error 'filename "The file is already open."))
         (assert (string? filecontents))
         (let ([input-port
                 (make-custom-textual-input-port filename
                    (lambda (string start n) 
                      @<Read from port@>)
                    (lambda () portpos)
                    (lambda (pos) (set! portpos pos))
                    (lambda () (begin
                               (file-data-set! file filecontents)
                               (file-open-set! file #f))))])
            (begin
               (file-data-set! file input-port)
               (file-open-set! file #t))
            input-port))))

@ Test Cases for Input Port.

@(io-test.ss@>=
(test-begin "test-make-virtual-input-port")
(define file1 (make-file "file1.txt" 4 "data"))
(make-virtual-textual-input-port file1)

(test-equal "is data a port?" #t (port? (file-data file1)))
(test-equal "is file set as open?" #t (file-open file1))
(test-equal "can read from the file" #\d (read-char (file-data file1)))
(test-equal "can use read procedure" "data" (read (file-data file1)))

(close-port (file-data file1))
(test-equal "port replaced by the string" "data" (file-data file1))
(test-equal "is file set as open?" #f (file-open file1))

(test-end "test-make-virtual-input-port")

@ The virtual input port reader maintains a current pointer into
the file-contents string and moves through it, maintaining the 
current port position (denoted port-pos).

\medskip

The reader fills the string starting at the start value that is passed
and filling in at most n characters (less if the file isn't that long).
The characters used are the ones from the string of the file. The
count is a numerical value representing the number of characters that
are pulled from the file-data string.

@c (string start n filecontents portpos)
@<Read from port@>=
(let ([end (+ start n)]
      [file-length (string-length filecontents)])
  (let loop ([i start]
             [count 0]
             [port-i portpos])
    (cond
      [(>= port-i file-length) (set! portpos port-i) count]
      [(>= i end) (set! portpos port-i) count]
      [else
        (begin
           (string-set! string i (string-ref filecontents port-i))
           (loop (fx1+ i) (fx1+ count) (fx1+ port-i)))])))

            
@ Above, we created an input port to read data. Similarly, we need a 
custom port to output data. This acts much the same way as the input
port we created earlier, such is it receives a node that must be of
type file, and the file must not already be open to create the port.
At first, |make-virtual-textual-output-port| will be written as if
the file-options for the port is set to truncate, which simply means
that when you write to a file, the contents of the file will be deleted
and replaced with whatever you add.

\medskip \noindent

@p
(define make-virtual-textual-output-port
   (lambda (node)
      (assert (file? node))
      (let ([file node]
            [filename (node-name node)]
            [filecontents (file-data node)]
	    [length (node-size node)]
            [contents ""])
       (when (file-open file)
         (error 'filename "The file is already open"))
       (assert (string? filecontents))
       (let ([output-port 
                (make-custom-textual-output-port filename
                   (lambda (string start n)
                      @<Write port@>)
                   #f
                   #f
                   (lambda () (begin
                                 (file-data-set! file contents)
                                 (file-open-set! file #f)
				 (node-size-set! file length))))])
       (file-data-set! file output-port)
       (file-open-set! file #t)
       output-port))))

@ Port Writer.

@c (string start n contents length)
@<Write port@>=
(let ([too-big? 
	(>= (+ (- n start) (current-space-used)) 
	    (filesystem-maxsize (virtual-filesystem)))])
  (when too-big?
    (error 'too-big "You do not have enough space to write this much"))
  (let ([s (substring string start (+ start n))])
    (begin
      (set! contents s)
      (set! length (string-length s))
      (string-length s))))


@ Test Cases for Output Port.

@(io-test.ss@>=
(test-begin "test-make-virtual-output-port")
  (define file1 (make-file "file1.txt" 4 "data"))
  (make-virtual-textual-output-port file1)

  (test-equal "is data a port?" #t (port? (file-data file1)))
  (test-equal "is file set as open?" #t (file-open file1))

  (write "this is a new string" (file-data file1))
  (close-port (file-data file1))

  (test-equal "port replaced by the new string" "this is a new string" (file-data file1))
  (test-equal "is file set as open?" #f (file-open file1))

(test-end "test-make-virtual-output-port")

(test-begin "test-port-writer")

  (fs-contents! (virtual-filesystem)                                 
      (cons (make-file "file" 0 "")
	    (cons (make-file "file1" 499 "data")(fs-contents (virtual-filesystem)))))
  (define file (car (fs-contents (virtual-filesystem))))
  (make-virtual-textual-output-port file)

  (put-string (file-data file) "hello")

(test-end "test-port-writer")



@* Convenience I/O.

@p
(define open-input-file
   (lambda (path)
      (assert (file-exists? path))
      (make-virtual-textual-input-port (path-lookup path))))

(define open-output-file
   (lambda (path)
      (assert (file-exists? path))
      (make-virtual-textual-input-port (path-lookup path))))


@q For the following procedures, should I use open-input-file, etc?

@p
(define call-with-input-file
  (lambda (path proc)
    (let ([node (path-lookup path)])
      (assert (file? node))
      (let ([port (make-virtual-textual-input-port node)])
	(let-values ([v* (proc port)])
	  (close-port port)
	  (apply values v*))))))

(define call-with-output-file
  (lambda (path proc)
    (let ([node (path-lookup path)])
      (assert (file? node))
      (let ([port (make-virtual-textual-output-port node)])
	(let-values ([v* (proc port)])
	  (close-port port)
	  (apply values v*))))))


(define with-input-from-file
  (lambda (path thunk)
    (let ([node (path-lookup path)])
      (assert (file? node))
      (dynamic-wind
	(lambda () (make-virtual-textual-input-port node))
	(lambda () thunk)
	(lambda () (close-port node))))))

(define with-output-to-file
  (lambda (path thunk)
    (let ([node (path-lookup path)])
      (assert (file? node))
      (dynamic-wind
	(lambda () (make-virtual-textual-output-port node))
	(lambda () thunk)
	(lambda () (close-port node))))))

(define file-exists?
  (lambda (path)
    (if (path-lookup path)
	#t
	#f)))

@ Test Cases for Convenience IO Library.
(test-begin "open-input-file/open-output-file")
(fs-contents! (virtual-filesystem)
	      (cons (make-directory "dir" 
		      (cons (make-file "file1" 4 "data")
			    '()))
		    (fs-contents (virtual-filesystem))))

(open-input-file "/dir/file1")

(test-equal? "does file1 contain a port?" \#t 
	     (port? (file-data 
		      (car (directory-nodes 
			(car (fs-contents (virtual-filesystem))))))))

(test-end "open-input-file/open-output-file")
@* Index.



     
